{"posts":[{"fileName":"solution-p9472","abstract":"","description":"通过简单证明可知，任意两个数列的首项和第二项一定有一个不同（若首项相同，但公差不同，所以第二项不会相同），因此当 m≠1m\\ne1m​=1 时只需先比较首项，若相等再比较第二项即可。当 m=1m=1m=1 时首项相同按输入顺序排序即可。 ...","title":"P9472 题解","tags":[{"index":-1,"name":"题解","slug":"solution","used":true,"link":"https://Happy-Code-HC.github.io/tag/solution/"}],"feature":"","link":"https://Happy-Code-HC.github.io/post/solution-p9472/","stats":{"text":"2 min read","time":68000,"words":230,"minutes":2},"isTop":false,"toc":"","date":"2023-07-23 14:46:20","dateFormat":"2023-07-23"},{"fileName":"solution-p9471","abstract":"","description":"很简单的签到题。 遍历字符串，判断每个字符是数字、小写还是大写，然后加到对应的统计变量里面。 #include&lt;iostream&gt; using namespace std; string s; int ans1,ans2,ans...","title":"P9471 题解","tags":[{"index":-1,"name":"题解","slug":"solution","used":true,"link":"https://Happy-Code-HC.github.io/tag/solution/"}],"feature":"","link":"https://Happy-Code-HC.github.io/post/solution-p9471/","stats":{"text":"1 min read","time":38000,"words":122,"minutes":1},"isTop":false,"toc":"","date":"2023-07-23 14:42:39","dateFormat":"2023-07-23"},{"fileName":"solution-p9451","abstract":"","description":"部分分解法 T≤100,a≤104T\\le 100,a\\le 10^4T≤100,a≤104 。判断后直接枚举即可。 保证 aaa 合法。不判断直接枚举即可。 保证 aaa 随机。不可以总司令即可。 正解 使用 __builtin_po...","title":"P9451 题解","tags":[{"index":-1,"name":"题解","slug":"solution","used":true,"link":"https://Happy-Code-HC.github.io/tag/solution/"}],"feature":"","link":"https://Happy-Code-HC.github.io/post/solution-p9451/","stats":{"text":"2 min read","time":71000,"words":240,"minutes":2},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E9%83%A8%E5%88%86%E5%88%86%E8%A7%A3%E6%B3%95\">部分分解法</a></li>\n<li><a href=\"#%E6%AD%A3%E8%A7%A3\">正解</a></li>\n<li><a href=\"#%E4%BB%A3%E7%A0%81\">代码</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2023-07-09 14:13:57","dateFormat":"2023-07-09"},{"fileName":"yugu23tgb15","abstract":"","description":"排列和组合 阶乘 n!=n×(n−1)×(n−2)×…×2×1n!=n\\times(n-1)\\times(n-2)\\times\\ldots\\times2\\times1n!=n×(n−1)×(n−2)×…×2×1 先让第一个人选一个位置，有 ...","title":"TG15 组合计数","tags":[{"index":-1,"name":"学习笔记","slug":"note","used":true,"link":"https://Happy-Code-HC.github.io/tag/note/"}],"feature":"","link":"https://Happy-Code-HC.github.io/post/yugu23tgb15/","stats":{"text":"4 min read","time":201000,"words":722,"minutes":4},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li><a href=\"#%E6%8E%92%E5%88%97%E5%92%8C%E7%BB%84%E5%90%88\">排列和组合</a>\n<ul>\n<li><a href=\"#%E9%98%B6%E4%B9%98\">阶乘</a></li>\n<li><a href=\"#%E7%BB%84%E5%90%88%E6%95%B0\">组合数</a></li>\n<li><a href=\"#%E7%BB%84%E5%90%88%E6%95%B0%E9%97%AE%E9%A2%98noip2016-tg-d2t1-p2822\">组合数问题（NOIP2016 TG D2T1 / P2822）</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%8F%AF%E9%87%8D%E6%8E%92%E5%88%97-%E5%8F%AF%E9%87%8D%E9%9B%86%E5%90%88%E5%92%8C%E5%9C%86%E6%8E%92%E5%88%97\">可重排列、可重集合和圆排列</a>\n<ul>\n<li><a href=\"#%E5%8F%AF%E9%87%8D%E6%8E%92%E5%88%97\">可重排列</a></li>\n<li><a href=\"#%E5%8F%AF%E9%87%8D%E9%9B%86%E5%90%88\">可重集合</a></li>\n<li><a href=\"#%E5%9C%86%E6%8E%92%E5%88%97\">圆排列</a></li>\n</ul>\n</li>\n<li><a href=\"#%E9%94%99%E6%8E%92%E9%97%AE%E9%A2%98\">错排问题</a></li>\n<li><a href=\"#%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86\">二项式定理</a></li>\n<li><a href=\"#%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86\">卢卡斯定理</a></li>\n<li><a href=\"#%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86\">容斥原理</a></li>\n</ul>\n</li>\n</ul>\n","date":"2023-03-19 17:00:00","dateFormat":"2023-03-19"},{"fileName":"solution-p2840","abstract":"","description":"定义 fif_ifi​ 为凑出 iii 元的纸币方式数，因此答案是 fwf_wfw​。 需要初始化 f0=1f_0=1f0​=1，因为凑出 000 元只有一种方式，就是不给钱。 凑出 iii 元的组方式是 iii 分别减去每种纸币面额的方式...","title":"P2840 题解","tags":[{"index":-1,"name":"题解","slug":"solution","used":true,"link":"https://Happy-Code-HC.github.io/tag/solution/"}],"feature":"","link":"https://Happy-Code-HC.github.io/post/solution-p2840/","stats":{"text":"2 min read","time":63000,"words":208,"minutes":2},"isTop":false,"toc":"","date":"2023-03-19 11:48:47","dateFormat":"2023-03-19"},{"fileName":"yugu23tgb14","abstract":"","description":"课件，补充资料 动态规划 纸币问题 1（P2842） 贪心的思路有问题，在面额为 1,5,111,5,111,5,11 元时不是最优解。 我们可以使用 dfs 求解，但是因为重复计算，所以效率很低。 将每个面额计算后的值记录下来，下次再使用...","title":"TG14 动态规划 1","tags":[{"index":-1,"name":"学习笔记","slug":"note","used":true,"link":"https://Happy-Code-HC.github.io/tag/note/"}],"feature":"","link":"https://Happy-Code-HC.github.io/post/yugu23tgb14/","stats":{"text":"8 min read","time":454000,"words":1655,"minutes":8},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li><a href=\"#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92\">动态规划</a>\n<ul>\n<li><a href=\"#%E7%BA%B8%E5%B8%81%E9%97%AE%E9%A2%98-1p2842\">纸币问题 1（P2842）</a></li>\n<li><a href=\"#%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2p1216\">数字三角形（P1216）</a></li>\n<li><a href=\"#%E7%8A%B6%E6%80%81-%E8%BD%AC%E7%A7%BB%E4%B8%8E%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE\">状态、转移与有向无环图</a>\n<ul>\n<li><a href=\"#%E7%8A%B6%E6%80%81\">状态</a></li>\n<li><a href=\"#%E8%BD%AC%E7%A7%BB\">转移</a></li>\n<li><a href=\"#%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE\">有向无环图</a></li>\n<li><a href=\"#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF\">解题思路</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#%E8%83%8C%E5%8C%85\">背包</a>\n<ul>\n<li><a href=\"#%E7%BA%B8%E5%B8%81%E9%97%AE%E9%A2%98-2p2840\">纸币问题 2（P2840）</a></li>\n<li><a href=\"#%E7%BA%B8%E5%B8%81%E9%97%AE%E9%A2%98-3p2834\">纸币问题 3（P2834）</a></li>\n<li><a href=\"#%E9%87%87%E8%8D%AFp1048\">采药（P1048）</a></li>\n<li><a href=\"#%E7%96%AF%E7%8B%82%E7%9A%84%E9%87%87%E8%8D%AFp1616\">疯狂的采药（P1616）</a></li>\n</ul>\n</li>\n<li><a href=\"#%E7%BA%BF%E6%80%A7-dp\">线性 dp</a>\n<ul>\n<li><a href=\"#lis%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98\">LIS（最长上升子序列）问题</a></li>\n<li><a href=\"#lcs%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98p1439\">LCS（最长公共子序列）问题（P1439）</a></li>\n<li><a href=\"#%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BBp2758\">编辑距离（P2758）</a></li>\n<li><a href=\"#%E9%AB%98%E7%BB%B4%E7%BA%BF%E6%80%A7-dp\">高维线性 dp</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%8C%BA%E9%97%B4-dp\">区间 dp</a>\n<ul>\n<li><a href=\"#%E5%9B%9E%E6%96%87%E5%AD%97%E4%B8%B2ioi2000-t1-p1435\">回文字串（IOI2000 T1 / P1435）</a></li>\n<li><a href=\"#%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6p1775\">石子合并（P1775）</a></li>\n<li><a href=\"#%E5%90%88%E5%94%B1%E9%98%9Fhnoi2010-p3205\">合唱队（HNOI2010 / P3205）</a></li>\n</ul>\n</li>\n<li><a href=\"#%E7%8E%AF%E5%BD%A2-dp\">环形 dp</a>\n<ul>\n<li><a href=\"#%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6noi1995-p1880\">石子合并（NOI1995 / P1880）</a></li>\n<li><a href=\"#%E7%8E%AF%E4%B8%8A%E6%9C%80%E5%A4%A7%E7%8B%AC%E7%AB%8B%E9%9B%86t321589\">环上最大独立集（T321589）</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2023-03-12 17:00:00","dateFormat":"2023-03-12"},{"fileName":"yugu23tga2","abstract":"","description":"前缀和 一个数组的前缀和可以理解为从数组开头到该位置的和。 利用前缀和可以 Θ(1)\\Theta(1)Θ(1) 的时间复杂度完成查询。 前缀和用于查询一个序列的区间和。 一维前缀和 一维前缀和可以在 Θ(n)\\Theta(n)Θ(n) 的时...","title":"TG2 线性优化技巧 1","tags":[{"index":-1,"name":"学习笔记","slug":"note","used":true,"link":"https://Happy-Code-HC.github.io/tag/note/"}],"feature":"","link":"https://Happy-Code-HC.github.io/post/yugu23tga2/","stats":{"text":"5 min read","time":242000,"words":764,"minutes":5},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li><a href=\"#%E5%89%8D%E7%BC%80%E5%92%8C\">前缀和</a>\n<ul>\n<li><a href=\"#%E4%B8%80%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C\">一维前缀和</a></li>\n<li><a href=\"#%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C\">二维前缀和</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%B7%AE%E5%88%86\">差分</a>\n<ul>\n<li><a href=\"#%E4%B8%80%E7%BB%B4%E5%B7%AE%E5%88%86\">一维差分</a></li>\n<li><a href=\"#%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86\">二维差分</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2023-01-15 17:00:00","dateFormat":"2023-01-15"},{"fileName":"solution-p8891","abstract":"","description":"思路 根据异或的性质，可以得出有且仅有 x⊕x=0x\\oplus x=0x⊕x=0。不同的两个数字异或结果一定不为 000。 因此对于每次操作，我们仅需将 ax←ax−ya_x \\gets a_x-yax​←ax​−y 即可。当 x=0x=...","title":"P8891 题解","tags":[{"index":-1,"name":"题解","slug":"solution","used":true,"link":"https://Happy-Code-HC.github.io/tag/solution/"}],"feature":"","link":"https://Happy-Code-HC.github.io/post/solution-p8891/","stats":{"text":"2 min read","time":68000,"words":225,"minutes":2},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E6%80%9D%E8%B7%AF\">思路</a></li>\n<li><a href=\"#%E4%BB%A3%E7%A0%81\">代码</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2022-12-11 14:50:59","dateFormat":"2022-12-11"},{"fileName":"yugu22nxj10","abstract":"","description":"多项式入门 小 A 有 333 种糖果，第一种有 111 颗，第二种有 222 颗，第三种有 333 颗，小 A 想吃三颗糖，请问有多少种吃法？ F(x)=(x0+x1)×(x0+x1+x2)×(x0+x1+x2+x3)\\text{F}(x...","title":"XJ10 第 5 周 授课","tags":[{"index":-1,"name":"学习笔记","slug":"note","used":true,"link":"https://Happy-Code-HC.github.io/tag/note/"}],"feature":"","link":"https://Happy-Code-HC.github.io/post/yugu22nxj10/","stats":{"text":"1 min read","time":40000,"words":147,"minutes":1},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li><a href=\"#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%85%A5%E9%97%A8\">多项式入门</a></li>\n</ul>\n</li>\n</ul>\n","date":"2022-08-27 16:00:00","dateFormat":"2022-08-27"},{"fileName":"yugu22nxj5","abstract":"","description":"Kruskal 算法 Kruskal 是用来求解最大/小生成树的算法。 一棵树可以被理解为 nnn 个结点，n−1n-1n−1 条边的连通图。 断开 kkk 条边，树会被分为 k+1k+1k+1 个连通块。 生成树：从一张 nnn 个点 ...","title":"XJ5 基础图论算法","tags":[{"index":-1,"name":"学习笔记","slug":"note","used":true,"link":"https://Happy-Code-HC.github.io/tag/note/"}],"feature":"","link":"https://Happy-Code-HC.github.io/post/yugu22nxj5/","stats":{"text":"5 min read","time":281000,"words":1120,"minutes":5},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li><a href=\"#kruskal-%E7%AE%97%E6%B3%95\">Kruskal 算法</a></li>\n<li><a href=\"#dijkstra-%E7%AE%97%E6%B3%95\">Dijkstra 算法</a></li>\n<li><a href=\"#floyd-%E7%AE%97%E6%B3%95\">Floyd 算法</a></li>\n</ul>\n</li>\n</ul>\n","date":"2022-08-22 12:00:00","dateFormat":"2022-08-22"},{"fileName":"yugu22nxj4","abstract":"","description":"map map 是一种映射容器，其头文件是 map。 功能 说明 map&lt;x,y&gt; m 建立一个名字为 mmm 的映射，下标类型为 x，元素类型为 y。 m[x]=y 将 mxm_xmx​ 的值设为 yyy ...","title":"XJ4 STL 的 set 与 priority_queue","tags":[{"index":-1,"name":"题解","slug":"solution","used":true,"link":"https://Happy-Code-HC.github.io/tag/solution/"}],"feature":"","link":"https://Happy-Code-HC.github.io/post/yugu22nxj4/","stats":{"text":"4 min read","time":237000,"words":942,"minutes":4},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li><a href=\"#map\"><code>map</code></a></li>\n<li><a href=\"#set\"><code>set</code></a></li>\n<li><a href=\"#multiset\"><code>multiset</code></a></li>\n<li><a href=\"#priority_queue\"><code>priority_queue</code></a></li>\n</ul>\n</li>\n</ul>\n","date":"2022-08-08 12:00:00","dateFormat":"2022-08-08"},{"fileName":"yugu22nxj7","abstract":"","description":"一元二次方程求根 ax2+bx+c=0(a≠0)ax^2+bx+c=0 (a \\neq 0) ax2+bx+c=0(a​=0) x2+bax+ca=0x^2+\\frac{b}{a}x+\\frac{c}{a}=0 x2+ab​x+ac​=0...","title":"XJ7 第 2 周 授课","tags":[{"index":-1,"name":"学习笔记","slug":"note","used":true,"link":"https://Happy-Code-HC.github.io/tag/note/"}],"feature":"","link":"https://Happy-Code-HC.github.io/post/yugu22nxj7/","stats":{"text":"2 min read","time":108000,"words":346,"minutes":2},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li><a href=\"#%E4%B8%80%E5%85%83%E4%BA%8C%E6%AC%A1%E6%96%B9%E7%A8%8B%E6%B1%82%E6%A0%B9\">一元二次方程求根</a></li>\n<li><a href=\"#%E4%B8%80%E5%85%83%E4%BA%8C%E6%AC%A1%E4%B8%8D%E7%AD%89%E5%BC%8F\">一元二次不等式</a></li>\n<li><a href=\"#%E5%B9%B6%E6%9F%A5%E9%9B%86\">并查集</a></li>\n</ul>\n</li>\n</ul>\n","date":"2022-08-06 16:00:00","dateFormat":"2022-08-06"},{"fileName":"yugu22nxj3","abstract":"","description":"字符串哈希 字符串哈希是一种将任意长度的字符串映射成一个非负整数的算法。 将字符串视为 PPP 进制数，对于字符集 [1]^{[1]}[1] 中的每一个字符，分配一个正整数。一般情况下，分配的数值都远小于 PPP，PPP 一般可以取 131...","title":"XJ3 字符串问题","tags":[{"index":-1,"name":"学习笔记","slug":"note","used":true,"link":"https://Happy-Code-HC.github.io/tag/note/"}],"feature":"","link":"https://Happy-Code-HC.github.io/post/yugu22nxj3/","stats":{"text":"8 min read","time":467000,"words":1925,"minutes":8},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li><a href=\"#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C\">字符串哈希</a></li>\n<li><a href=\"#kmp\">KMP</a></li>\n<li><a href=\"#%E5%AD%97%E5%85%B8%E6%A0%91\">字典树</a></li>\n</ul>\n</li>\n</ul>\n","date":"2022-08-01 12:00:00","dateFormat":"2022-08-01"},{"fileName":"solution-p8219","abstract":"","description":"思路 40 分 枚举 LLL 到 RRR 之间的每个 f(x)f(x)f(x) 的值，用“打擂台法”求出最大值。 注：“打擂台法”指如果当前值大于最大值，那么当前值就是最大值。详细解释请参考《深入浅出程序设计竞赛 - 基础篇》语言入门部分。...","title":"P8219 题解","tags":[{"index":-1,"name":"题解","slug":"solution","used":true,"link":"https://Happy-Code-HC.github.io/tag/solution/"}],"feature":"","link":"https://Happy-Code-HC.github.io/post/solution-p8219/","stats":{"text":"2 min read","time":63000,"words":241,"minutes":2},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E6%80%9D%E8%B7%AF\">思路</a>\n<ul>\n<li><a href=\"#40-%E5%88%86\">40 分</a></li>\n<li><a href=\"#100-%E5%88%86\">100 分</a></li>\n</ul>\n</li>\n<li><a href=\"#%E6%8F%90%E9%86%92\">提醒</a></li>\n<li><a href=\"#%E4%BB%A3%E7%A0%81\">代码</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2022-03-06 20:55:03","dateFormat":"2022-03-06"},{"fileName":"solution-p8152","abstract":"","description":"思路 我们发现每次操作都会去除右下角的 111 个格子，并在右下角添加 n×nn \\times nn×n 个格子。 经过 kkk 次操作后，共减少了 kkk 个格子，增加了 n×n×kn \\times n \\times kn×n×k 个格子...","title":"P8152 题解","tags":[{"index":-1,"name":"题解","slug":"solution","used":true,"link":"https://Happy-Code-HC.github.io/tag/solution/"}],"feature":"","link":"https://Happy-Code-HC.github.io/post/solution-p8152/","stats":{"text":"2 min read","time":71000,"words":237,"minutes":2},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E6%80%9D%E8%B7%AF\">思路</a></li>\n<li><a href=\"#%E6%8F%90%E9%86%92\">提醒</a></li>\n<li><a href=\"#%E4%BB%A3%E7%A0%81\">代码</a></li>\n<li><a href=\"#%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97\">更新日志</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2022-02-14 16:09:51","dateFormat":"2022-02-14"},{"fileName":"solution-p8318","abstract":"","description":"思路 很明显我们恢复序列时要把加法变成减法，把乘法变成除法，但因为猴子是从前往后操作的，所以我们要从后往前恢复。 特别且显然地，当 x=yx=yx=y，新的 xxx 就等于原来的 xxx 两倍或平方。 如果 x=yx=yx=y，且操作为...","title":"P8318 题解","tags":[{"index":-1,"name":"题解","slug":"solution","used":true,"link":"https://Happy-Code-HC.github.io/tag/solution/"}],"feature":"","link":"https://Happy-Code-HC.github.io/post/solution-p8318/","stats":{"text":"2 min read","time":82000,"words":278,"minutes":2},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E6%80%9D%E8%B7%AF\">思路</a></li>\n<li><a href=\"#%E6%8F%90%E9%86%92\">提醒</a></li>\n<li><a href=\"#%E4%BB%A3%E7%A0%81\">代码</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2022-02-11 15:34:21","dateFormat":"2022-02-11"},{"fileName":"solution-p8071","abstract":"","description":"思路 我们想要知道比 H:MH:MH:M 早 454545 分钟的时间就要把 MMM 减少 454545。 但是这题就这么简单吗？不是的，有可能提前 454545 分钟就到了上一个小时，如果 M&lt;0M&lt;0M&lt;0 就到了上一...","title":"P8071 题解","tags":[{"index":-1,"name":"题解","slug":"solution","used":true,"link":"https://Happy-Code-HC.github.io/tag/solution/"}],"feature":"","link":"https://Happy-Code-HC.github.io/post/solution-p8071/","stats":{"text":"2 min read","time":90000,"words":340,"minutes":2},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E6%80%9D%E8%B7%AF\">思路</a></li>\n<li><a href=\"#%E6%8F%90%E9%86%92\">提醒</a></li>\n<li><a href=\"#%E4%BB%A3%E7%A0%81\">代码</a></li>\n<li><a href=\"#%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97\">更新日志</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2022-01-24 13:08:42","dateFormat":"2022-01-24"},{"fileName":"solution-p8032","abstract":"","description":"思路 我们枚举输入的数组的每个值。 如果该值为 {，除第一行以外换一行，然后输出缩进，然后加 222 个空格的缩进。 如果该值为 }，减掉 222 个空格的缩进，然后换一行输出缩进和 }。 如果该值为 ,，直接输出。 如果该值为数组元素且...","title":"P8032 题解","tags":[{"index":-1,"name":"题解","slug":"solution","used":true,"link":"https://Happy-Code-HC.github.io/tag/solution/"}],"feature":"","link":"https://Happy-Code-HC.github.io/post/solution-p8032/","stats":{"text":"2 min read","time":70000,"words":246,"minutes":2},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E6%80%9D%E8%B7%AF\">思路</a></li>\n<li><a href=\"#%E6%8F%90%E9%86%92\">提醒</a></li>\n<li><a href=\"#%E4%BB%A3%E7%A0%81\">代码</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2022-01-12 16:34:42","dateFormat":"2022-01-12"},{"fileName":"solution-p7917","abstract":"","description":"思路 这题需要将 nnn 个整数相邻两个进行加减运算，问最大是多少。但实际上就是在 nnn 个数字间填上加减号，求最大值。 加一个整数原数变大，减一个负数原数变小。 但算式开头默认有个加号，所以第一个数必须要加上，不管它是否是负数。 我们定...","title":"P7917 题解","tags":[{"index":-1,"name":"题解","slug":"solution","used":true,"link":"https://Happy-Code-HC.github.io/tag/solution/"}],"feature":"","link":"https://Happy-Code-HC.github.io/post/solution-p7917/","stats":{"text":"2 min read","time":77000,"words":304,"minutes":2},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E6%80%9D%E8%B7%AF\">思路</a></li>\n<li><a href=\"#%E6%8F%90%E9%86%92\">提醒</a></li>\n<li><a href=\"#%E4%BB%A3%E7%A0%81\">代码</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2021-11-01 16:35:08","dateFormat":"2021-11-01"},{"fileName":"solution-p7901","abstract":"","description":"思路 这题是道数学题。 每经过一次琢喵就会经过坐标为 (x,y)(x,y)(x,y) 的点，但是起点可以是的任意点，那么琢喵在哪里就对答案没有影响。 所以我们找矩形的点数 nnn 和步数 kkk 的关系,也就是找 2n×2n2n \\time...","title":"P7901 题解","tags":[{"index":-1,"name":"题解","slug":"solution","used":true,"link":"https://Happy-Code-HC.github.io/tag/solution/"}],"feature":"","link":"https://Happy-Code-HC.github.io/post/solution-p7901/","stats":{"text":"2 min read","time":85000,"words":333,"minutes":2},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E6%80%9D%E8%B7%AF\">思路</a></li>\n<li><a href=\"#%E6%8F%90%E9%86%92\">提醒</a></li>\n<li><a href=\"#%E4%BB%A3%E7%A0%81\">代码</a></li>\n<li><a href=\"#%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97\">更新日志</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2021-10-21 20:11:13","dateFormat":"2021-10-21"}],"tags":[{"index":-1,"name":"题解","slug":"solution","used":true,"link":"https://Happy-Code-HC.github.io/tag/solution/","count":13},{"index":-1,"name":"学习笔记","slug":"note","used":true,"link":"https://Happy-Code-HC.github.io/tag/note/","count":7}],"menus":[{"link":"/","name":"首页","openType":"Internal"},{"link":"/tags","name":"标签","openType":"Internal"},{"link":"/friends","name":"友链","openType":"Internal"}],"themeConfig":{"themeName":"gridea-theme-pure-1.3.2","postPageSize":10,"archivesPageSize":50,"siteName":"HappyCode's Blog","siteDescription":"Think twice, code once.","footerInfo":"Powered by <a href=\"https://github.com/getgridea/gridea\" target=\"_blank\">Gridea</a>","showFeatureImage":true,"domain":"https://Happy-Code-HC.github.io","postUrlFormat":"SLUG","tagUrlFormat":"SHORT_ID","dateFormat":"YYYY-MM-DD","feedFullText":true,"feedCount":10,"archivesPath":"archives","postPath":"post","tagPath":"tag"},"customConfig":{"APP_ID":"jgqWQkygxwa588WZBisDTk7h-gzGzoHsz","APP_KEY":"jHQ5aFwqoNabaiGy3g3eLcF6","about":"","avatar":"","caf":"#84fab0","ccf":"#5f6169","ccs":"#999fa7","ctf":"#ffffff","cts":"#dddddd","customCss":"","descfriend":"","dribbble":"","facebook":"","friends":[{"description":"计算机科学教育新生态","siteLink":"https://www.luogu.com.cn/","siteLogo":"/images/luogu.png","siteName":"洛谷"}],"ga":"","github":"https://github.com/Happy-Code-HC","isEnabledCustomColor":false,"pageSize":"5","placeholder":"Think twice, code once.","recordIp":true,"skin":"black","twitter":"","vMaxWidth":"1000","vPadding":"2.5%","vPercentWidth":"100","valine":true,"visitor":true,"weibo":"","zhihu":"https://www.zhihu.com/people/happycode-51"},"utils":{"now":1690095254216}}
