{"posts":[{"title":"P9472 题解","content":"通过简单证明可知，任意两个数列的首项和第二项一定有一个不同（若首项相同，但公差不同，所以第二项不会相同），因此当 m≠1m\\ne1m​=1 时只需先比较首项，若相等再比较第二项即可。当 m=1m=1m=1 时首项相同按输入顺序排序即可。 注意 ai,0a_{i,0}ai,0​ 可以为负数，如果首项相等比较公差只有 70pts。 #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; int n,m; struct node{ int x,n; }a[100005]; bool cmp(node a,node b){ if(a.x==b.x){ if(m!=1){ return 1ll*a.x*a.n&lt;1ll*b.x*b.n; }else{ return a.n&lt;b.n; } } return a.x&lt;b.x; } int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i].x; a[i].n=i; } sort(a+1,a+1+n,cmp); for(int i=1;i&lt;=n;i++){ cout&lt;&lt;a[i].n&lt;&lt;' '; } return 0; } ","link":"https://Happy-Code-HC.github.io/post/solution-p9472/"},{"title":"P9471 题解","content":"很简单的签到题。 遍历字符串，判断每个字符是数字、小写还是大写，然后加到对应的统计变量里面。 #include&lt;iostream&gt; using namespace std; string s; int ans1,ans2,ans3; int main(){ cin&gt;&gt;s; for(int i=0;i&lt;s.length();i++){ if(s[i]&gt;='0' and s[i]&lt;='9'){ ans1++; }else if(s[i]&gt;='a' and s[i]&lt;='z'){ ans2++; }else if(s[i]&gt;='A' and s[i]&lt;='Z'){ ans3++; } } cout&lt;&lt;ans1&lt;&lt;' '&lt;&lt;ans2&lt;&lt;' '&lt;&lt;ans3&lt;&lt;endl; return 0; } ","link":"https://Happy-Code-HC.github.io/post/solution-p9471/"},{"title":"P9451 题解","content":"部分分解法 T≤100,a≤104T\\le 100,a\\le 10^4T≤100,a≤104 。判断后直接枚举即可。 保证 aaa 合法。不判断直接枚举即可。 保证 aaa 随机。不可以总司令即可。 正解 使用 __builtin_popcountll(long long) 函数，然后判断是否合法。 不难发现，popcount 的值为 000 或 111 时，下一个合法数即是 a+1a+1a+1。 而 popcount 的值为 222 时，下一个合法值为在二进制下最后一个 111 的位置 +1+1+1。即 2ctz(a)2^{\\text{ctz}(a)}2ctz(a)，ctz\\text{ctz}ctz 为末尾 000 的个数。 记得开 long long。 代码 #include&lt;iostream&gt; using namespace std; int t; int main(){ cin&gt;&gt;t; while(t--){ long long a,pop; cin&gt;&gt;a; pop=__builtin_popcountll(a); if(pop&gt;=3){ cout&lt;&lt;&quot;No,Commander&quot;&lt;&lt;endl; }else{ if(pop&lt;=1){ cout&lt;&lt;a+1&lt;&lt;endl; }else if(pop==2){ long long ans=1,b=__builtin_ctzll(a); for(long long i=1;i&lt;=b;i++){ ans*=2ll; } ans+=a; cout&lt;&lt;ans&lt;&lt;endl; } } } return 0; } ","link":"https://Happy-Code-HC.github.io/post/solution-p9451/"},{"title":"TG15 组合计数","content":"排列和组合 阶乘 n!=n×(n−1)×(n−2)×…×2×1n!=n\\times(n-1)\\times(n-2)\\times\\ldots\\times2\\times1n!=n×(n−1)×(n−2)×…×2×1 先让第一个人选一个位置，有 nnn 种选法。再让第二个人选一个位置，有 n−1n-1n−1 种选法.以此类推。 组合数 Cnm=n!÷m!÷(n−m)!C^m_n=n!\\div m!\\div(n-m)!Cnm​=n!÷m!÷(n−m)! 把 nnn 个球排成一排，选前 mmm 个，排成一排的方案数是 n!n!n!。由于我们只关心前 mmm 个球是什么，与顺序无关，所以就是 n!÷m!÷(n−m)!n!\\div m!\\div(n-m)!n!÷m!÷(n−m)!。 Cnm=Cn−1m+Cn−1m−1C_n^m=C_{n-1}^m+C_{n-1}^{m-1}Cnm​=Cn−1m​+Cn−1m−1​ 考虑最后一个球选不选，如果选，方案数是 Cn−1m−1C_{n-1}^{m-1}Cn−1m−1​，否则是 Cn−1mC_{n-1}^mCn−1m​。 组合数问题（NOIP2016 TG D2T1 / P2822） 预处理出 CijC_i^jCij​，求二维前缀和即可。 可重排列、可重集合和圆排列 可重排列 有 nnn 种颜色的球，第 iii 种有 aia_iai​ 个。把这些球排成一排，有几种方法？ 令 SSS 为 aaa 的和。 答案为 CSa1×CS−a1a2×CS−a1−a2a3×…C_S^{a_1}\\times C_{S-a_1}^{a_2}\\times C_{S-a_1-a_2}^{a_3}\\times\\ldotsCSa1​​×CS−a1​a2​​×CS−a1​−a2​a3​​×…，化解后得 S!a1!×a2!×a3!×…×an!\\frac{S!}{a_1!\\times a_2!\\times a_3!\\times\\ldots\\times a_n!}a1​!×a2​!×a3​!×…×an​!S!​ 另外一种理解，先将 SSS 个数随便排，有 S!S!S! 种方案。但是有 aia_iai​ 个球颜色相同，所以除以 ai!a_i!ai​!。可以直接得出化简后的通项公式。 可重集合 有 nnn 种颜色的球，每种球有无限个，求选出 mmm 个球的方案数。 在 mmm 个球中插入 n−1n-1n−1 个隔板，两个隔板之间的球表示每一类选几个。 这样相当于有 m+1−1m+1-1m+1−1 个空位，选 mmm 个放球，n−1n-1n−1 个放隔板。 方案数是 Cm+n−1n−1C_{m+n-1}^{n-1}Cm+n−1n−1​。 圆排列 nnn 个人站成一个圈有几种站法？ 如果把旋转看成不同的，方案数是 n!n!n!，所以实际方案数是 n!n=(n−1)!\\frac{n!}{n}=(n-1)!nn!​=(n−1)! 错排问题 有 nnn 个小朋友和 nnn 个凳子，第 iii 个小朋友坐在 iii 号凳子上。现在让这些小朋友站起来，重新找凳子坐下，不能坐到原来的凳子上。有多少种方案？ 二项式定理 (x+y)n=∑i=0n(ni)xiyn−i(x+y)^n=\\sum_{i=0}^n\\dbinom{n}{i}x^iy^{n-i} (x+y)n=i=0∑n​(in​)xiyn−i 卢卡斯定理 (nm) mod p=(⌊np⌋⌊mp⌋)(n mod pm mod p) mod p\\dbinom{n}{m}\\bmod p=\\dbinom{\\left\\lfloor\\frac{n}{p}\\right\\rfloor}{\\left\\lfloor\\frac{m}{p}\\right\\rfloor}\\dbinom{n\\bmod p}{m\\bmod p}\\bmod p (mn​)modp=(⌊pm​⌋⌊pn​⌋​)(mmodpnmodp​)modp 容斥原理 ∣A∪B∣=∣A∣+∣B∣−∣A∩B∣|A\\cup B|=|A|+|B|-|A\\cap B| ∣A∪B∣=∣A∣+∣B∣−∣A∩B∣ ","link":"https://Happy-Code-HC.github.io/post/yugu23tgb15/"},{"title":"P2840 题解","content":"定义 fif_ifi​ 为凑出 iii 元的纸币方式数，因此答案是 fwf_wfw​。 需要初始化 f0=1f_0=1f0​=1，因为凑出 000 元只有一种方式，就是不给钱。 凑出 iii 元的组方式是 iii 分别减去每种纸币面额的方式数的和，即 ∑j=1nfi−aj\\sum_{j=1}^n f_{i-a_j}∑j=1n​fi−aj​​。状态转移方程如下。 fi=∑j=1nfi−ajf_i=\\sum_{j=1}^n f_{i-a_j} fi​=j=1∑n​fi−aj​​ 注意取模。注意数组溢出。 #include&lt;iostream&gt; using namespace std; int n,w,a[1005],f[10005]; const int mod=1e9+7; int main(){ cin&gt;&gt;n&gt;&gt;w; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i]; } f[0]=1; for(int i=1;i&lt;=w;i++){ for(int j=1;j&lt;=n;j++){ if(i-a[j]&gt;=0){ f[i]=(f[i]+f[i-a[j]])%mod; } } } cout&lt;&lt;(f[w]%mod)&lt;&lt;endl; return 0; } ","link":"https://Happy-Code-HC.github.io/post/solution-p2840/"},{"title":"TG14 动态规划 1","content":"课件，补充资料 动态规划 纸币问题 1（P2842） 贪心的思路有问题，在面额为 1,5,111,5,111,5,11 元时不是最优解。 我们可以使用 dfs 求解，但是因为重复计算，所以效率很低。 将每个面额计算后的值记录下来，下次再使用直接返回。时间复杂度 O(nw)O(nw)O(nw)。这种方法叫做记忆化搜索。 我们可以直接使用数组计算，从面额为 111 枚举到面额为 www，计算每个面额需要多少张纸币。 数字三角形（P1216） 贪心依然不对。可以使用效率较低的 dfs。 把每个点到底端路径的最大值存下来，就是记忆化搜索。 利用记忆化搜索的思想，直接用数组解决，就是 dp。 状态、转移与有向无环图 状态 问题所在的局面，即“凑够 www 元需要多少张”“从 (x,y)(x,y)(x,y) 走到最下层的最大数字和”。状态的定义是明确的，具有无后效性以及最优子结构性质。 如何确定状态成了关键问题，可以使用朴素的搜索算法推出状态。 转移 转移是状态之间的关系，类似于递推。通过“状态转移方程”来描述。 有向无环图 把状态看成节点，把转移看成有向边，那么 dp 的模型可以看成一个有向无环图。 我们按照拓扑序遍历整张图即可解决问题。绝大多数 dp 对于遍历的顺序或层次是明显的，我们称之为阶段。 解题思路 确定状态 寻找转移 划分阶段 按照顺序求解 背包 纸币问题 2（P2840） fi=∑j=1nfi−ajf_i=\\sum_{j=1}^n f_{i-a_j} fi​=j=1∑n​fi−aj​​ 纸币问题 3（P2834） 采药（P1048） 经典 01 背包板子。 定义 fi,jf_{i,j}fi,j​ 为采前 iii 株用时 jjj 的最大价值。 fi,j=max⁡{fi−1,j−ti+vi,fi−1,j}f_{i,j}=\\max\\{f_{i-1,j-t_i}+v_i,f_{i-1,j}\\} fi,j​=max{fi−1,j−ti​​+vi​,fi−1,j​} 我们可以缩掉第一维，然后倒着走。 fj=max⁡{fj−ti+vi,fj}f_j=\\max\\{f_{j-t_i}+v_i,f_j\\} fj​=max{fj−ti​​+vi​,fj​} 疯狂的采药（P1616） 完全背包板子。 01 背包内层循环改成正着走即可。 线性 dp 线性状态动态规划是一类状态定义与题设内容线性相关的 dp。 LIS（最长上升子序列）问题 给出长为 n≤105n \\le 10^5n≤105 的正整数序列 aaa，求序列中最长上升子序列的长度。 定义 fif_ifi​ 为以 iii 结尾的最长长度。 fi=max⁡j&lt;i∧aj≤ai{fj}+1f_i=\\max_{j&lt;i \\land a_j\\le a_i}\\{f_j\\}+1 fi​=j&lt;i∧aj​≤ai​max​{fj​}+1 LCS（最长公共子序列）问题（P1439） 子序列：从序列中删掉若干个数剩下的序列。 定义 fi,jf_{i,j}fi,j​ 为 AAA 中前 iii 个数与 BBB 中前 jjj 个数的 LCS 长度，最终答案是 fn,mf_{n,m}fn,m​。 fi,j={fi−1,j−1+1,Ai=Bjmax⁡{fi−1,j,fi,j−1},Ai≠Bjf_{i,j}=\\begin{cases} f_{i-1,j-1}+1,A_i=B_j\\\\ \\max\\{f_{i-1,j},f_{i,j-1}\\},A_i\\ne B_j\\\\ \\end{cases}fi,j​={fi−1,j−1​+1,Ai​=Bj​max{fi−1,j​,fi,j−1​},Ai​​=Bj​​ 编辑距离（P2758） 定义 fi,jf_{i,j}fi,j​ 为将 A1∼iA_{1\\sim i}A1∼i​ 转换为 B1∼jB_{1\\sim j}B1∼j​ 的最少次数，f0,0=1f_{0,0}=1f0,0​=1。 删除 fi,j=min⁡{fi,j−1,fj,i−1}+1f_{i,j}=\\min\\{f_{i,j-1},f_{j,i-1}\\}+1fi,j​=min{fi,j−1​,fj,i−1​}+1 插入 fi,j=min⁡{fi,j−1,fj,i−1}+1f_{i,j}=\\min\\{f_{i,j-1},f_{j,i-1}\\}+1fi,j​=min{fi,j−1​,fj,i−1​}+1 修改 fi,j={fi−1,j−1,Ai=Bjfi−1,j−1+1,Ai≠Bjf_{i,j}=\\begin{cases}f_{i-1,j-1},A_i=B_j\\\\f_{i-1,j-1}+1,A_i\\ne B_j\\end{cases}fi,j​={fi−1,j−1​,Ai​=Bj​fi−1,j−1​+1,Ai​​=Bj​​ 高维线性 dp 有一个 nnn 层的数字金字塔，你有 k(k≤n)k(k\\le n)k(k≤n) 次机会，每次可以将金字塔中的任何一个数字乘以 333（不能对同一个数字反复成乘 333），求从最高点到底部任意一点的最大数字和（每一步只能往下走）。n≤100n \\le 100n≤100。 使用数字金字塔的转移方程无法体现出 kkk 次乘 333 限制。因此定义 fi,j,kf_{i,j,k}fi,j,k​ 为走到 (i,j)(i,j)(i,j) 且使用了 kkk 次乘 333。 有向左且乘 333，向左不乘 333，向右且乘 333，向右不乘 333 四种转移。 初始化定义 f1,1,0=a1,1,f1,1,1=3×a1,1f_{1,1,0}=a_{1,1},f_{1,1,1}=3\\times a_{1,1}f1,1,0​=a1,1​,f1,1,1​=3×a1,1​，最终答案为 f1,1,kf_{1,1,k}f1,1,k​。 区间 dp 区间 dp 比较明显的特征是其状态定义通常包括区间信息 (l,r)(l,r)(l,r)，转移也通常为从子区间扩展到当前区间。 回文字串（IOI2000 T1 / P1435） 定义 fl,rf_{l,r}fl,r​ 为将区间 (l,r)(l,r)(l,r) 变为回文的最小操作数。 fl,r={fl+1,r−1+1,sl=srmin⁡{fl+1,r+1,fl,r−1+1},sl≠srf_{l,r}=\\begin{cases} f_{l+1,r-1}+1,s_l=s_r\\\\ \\min\\{f_{l+1,r}+1,f_{l,r-1}+1\\},s_l\\ne s_r\\\\ \\end{cases}fl,r​={fl+1,r−1​+1,sl​=sr​min{fl+1,r​+1,fl,r−1​+1},sl​​=sr​​ 石子合并（P1775） 定义 fl,rf_{l,r}fl,r​ 为将区间 (l,r)(l,r)(l,r) 合为一堆的最小代价。 fl,r=min⁡l≤k≤r{fl,k+fk+1,r}+sumr−suml−1f_{l,r}=\\min_{l\\le k\\le r}\\{f_{l,k}+f_{k+1,r}\\}+sum_r-sum_{l-1} fl,r​=l≤k≤rmin​{fl,k​+fk+1,r​}+sumr​−suml−1​ 合唱队（HNOI2010 / P3205） 环形 dp 石子合并（NOI1995 / P1880） 断环成链，然后倍长链，每次取一个长度为 nnn 的子区间，滑动 nnn 次。 环上最大独立集（T321589） 定义 fi,0/1f_{i,0/1}fi,0/1​ 为前 iii 个最大答案，第 iii 个是否选择。 fi,0=max⁡{fi−1,0,fi−1,1}f_{i,0}=\\max\\{f_{i-1,0},f_{i-1,1}\\} fi,0​=max{fi−1,0​,fi−1,1​} fi,1=fi−1,0+aif_{i,1}=f_{i-1,0}+a_i fi,1​=fi−1,0​+ai​ 最终答案为 max⁡{fn,0,fn,1}\\max\\{f_{n,0},f_{n,1}\\}max{fn,0​,fn,1​}。 但是这种方法是在链上的，在环上无法断环成链。 可以先忽略成环的一条边，然后对剩下的部分进行 dp，最后考虑这条边的影响。 ","link":"https://Happy-Code-HC.github.io/post/yugu23tgb14/"},{"title":"TG2 线性优化技巧 1","content":"前缀和 一个数组的前缀和可以理解为从数组开头到该位置的和。 利用前缀和可以 Θ(1)\\Theta(1)Θ(1) 的时间复杂度完成查询。 前缀和用于查询一个序列的区间和。 一维前缀和 一维前缀和可以在 Θ(n)\\Theta(n)Θ(n) 的时间复杂度完成统计。 si=∑j=1iaj=si−1+ais_i=\\sum_{j=1}^{i}a_j=s_{i-1}+a_i si​=j=1∑i​aj​=si−1​+ai​ ∑i=lrai=sr−sl−1\\sum_{i=l}^{r}a_i=s_r-s_{l-1} i=l∑r​ai​=sr​−sl−1​ 二维前缀和 二维前缀和可以在 Θ(nm)\\Theta(nm)Θ(nm) 的时间复杂度完成统计。 si,j=∑k=1i∑l=1jak,l=si−1,j+si,j−1−si−1,j−1+ais_{i,j}=\\sum_{k=1}^{i}\\sum_{l=1}^{j}a_{k,l}=s_{i-1,j}+s_{i,j-1}-s_{i-1,j-1}+a_i si,j​=k=1∑i​l=1∑j​ak,l​=si−1,j​+si,j−1​−si−1,j−1​+ai​ ∑i=x1x2∑j=y1y2ai,j=sx2,y2+sx1−1,y1−1−sx2,y1−1−sx1−1,y2\\sum_{i=x1}^{x2}\\sum_{j=y1}^{y2}a_{i,j}=s_{x2,y2}+s_{x1-1,y1-1}-s_{x2,y1-1}-s_{x1-1,y2} i=x1∑x2​j=y1∑y2​ai,j​=sx2,y2​+sx1−1,y1−1​−sx2,y1−1​−sx1−1,y2​ 差分 一个数组的差分可以理解为数组中相邻两个数据的差。 对差分数组求前缀和即可得到原数组。 利用差分可以 Θ(1)\\Theta(1)Θ(1) 的时间复杂度完成修改。 前缀和用于快速修改序列中的区间，并在所有修改完成后读取。 一维差分 si={a1,i=1ai−ai−1, 2≤i≤ns_i=\\begin{cases}a_1,i=1\\\\a_i-a_{i-1},\\ 2 \\le i \\le n\\end{cases} si​={a1​,i=1ai​−ai−1​, 2≤i≤n​ 实际编程中若 iii 从 111 起则无需考虑 i=1i=1i=1 的特殊情况。 将区间 [l,r][l,r][l,r] 增加 zzz 可以转化为 sl=sl+z,sr+1=sr+1−zs_l=s_l+z,s_{r+1}=s_{r+1}-zsl​=sl​+z,sr+1​=sr+1​−z。 二维差分 si,j={a1,1, i=1,j=1a1,j, i=1,2≤j≤mai,1, 2≤i≤n,j=1ai,j−ai−1,j−ai,j−1+ai−1,j−1, 2≤i≤n,2≤j≤ms_{i,j}=\\begin{cases}a_{1,1},\\ i=1,j=1\\\\a_{1,j},\\ i=1,2 \\le j \\le m\\\\a_{i,1},\\ 2 \\le i \\le n,j=1\\\\a_{i,j}-a_{i-1,j}-a_{i,j-1}+a_{i-1,j-1},\\ 2 \\le i \\le n,2 \\le j \\le m\\end{cases} si,j​=⎩⎪⎪⎪⎨⎪⎪⎪⎧​a1,1​, i=1,j=1a1,j​, i=1,2≤j≤mai,1​, 2≤i≤n,j=1ai,j​−ai−1,j​−ai,j−1​+ai−1,j−1​, 2≤i≤n,2≤j≤m​ 实际编程中若 i,ji,ji,j 从 111 起则无需考虑前三种特殊情况。 将区间 [(x1,y1),(x2,y2)][(x_1,y_1),(x_2,y_2)][(x1​,y1​),(x2​,y2​)] 增加 zzz 可以转化为 sx1,y1=sx1,y1+z,sx2+1,y2+1=sx2+1,y2+1+z,sx1,y2+1=sx1,y2+1−z,sx2+1,y1=sx2+1,y1−zs_{x_1,y_1}=s_{x_1,y_1}+z,s_{x_2+1,y_2+1}=s_{x_2+1,y_2+1}+z,s_{x_1,y_2+1}=s_{x_1,y_2+1}-z,s_{x_2+1,y_1}=s_{x_2+1,y_1}-zsx1​,y1​​=sx1​,y1​​+z,sx2​+1,y2​+1​=sx2​+1,y2​+1​+z,sx1​,y2​+1​=sx1​,y2​+1​−z,sx2​+1,y1​​=sx2​+1,y1​​−z。 ","link":"https://Happy-Code-HC.github.io/post/yugu23tga2/"},{"title":"P8891 题解","content":"思路 根据异或的性质，可以得出有且仅有 x⊕x=0x\\oplus x=0x⊕x=0。不同的两个数字异或结果一定不为 000。 因此对于每次操作，我们仅需将 ax←ax−ya_x \\gets a_x-yax​←ax​−y 即可。当 x=0x=0x=0，我们什么都不做。 时间复杂度 O(n+m)O(n+m)O(n+m)，在 1≤n,m≤1061 \\le n,m \\le 10^61≤n,m≤106 情况下不会超时。 注意由于 −108≤y≤108-10^8 \\le y \\le 10^8−108≤y≤108，经过操作后 aaa 数组可能会超过 int 范围，需要使用 long long。 代码 #include&lt;iostream&gt; using namespace std; int n,m; long long a[1000005]; int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i]; } while(m--){ int x,y; cin&gt;&gt;x&gt;&gt;y; if(x!=0){ a[x]=a[x]-y; } } for(int i=1;i&lt;=n;i++){ cout&lt;&lt;a[i]&lt;&lt;' '; } return 0; } ","link":"https://Happy-Code-HC.github.io/post/solution-p8891/"},{"title":"XJ10 第 5 周 授课","content":"多项式入门 小 A 有 333 种糖果，第一种有 111 颗，第二种有 222 颗，第三种有 333 颗，小 A 想吃三颗糖，请问有多少种吃法？ F(x)=(x0+x1)×(x0+x1+x2)×(x0+x1+x2+x3)\\text{F}(x)=(x^0+x^1) \\times (x^0+x^1+x^2) \\times (x^0+x^1+x^2+x^3) F(x)=(x0+x1)×(x0+x1+x2)×(x0+x1+x2+x3) 显然 F(x)\\text{F}(x)F(x) 是一个关于 xxx 的多项式，x3x^3x3 对应的项数就是本题答案。 x3x^3x3 中的三次方，是由三个括号中选的三个数加起来得到的。 ","link":"https://Happy-Code-HC.github.io/post/yugu22nxj10/"},{"title":"XJ5 基础图论算法","content":"Kruskal 算法 Kruskal 是用来求解最大/小生成树的算法。 一棵树可以被理解为 nnn 个结点，n−1n-1n−1 条边的连通图。 断开 kkk 条边，树会被分为 k+1k+1k+1 个连通块。 生成树：从一张 nnn 个点 mmm 条边的图中选出 n−1n-1n−1 条边，构成一棵树。 最小生成树：边权和最小的生成树。 最大生成树：边权和最大的生成树。 反向考虑一棵树的构建过程。 一开始是 nnn 个独立的联通块，每增加一条边，减少一个联通块。 直到选出 n−1n-1n−1 条边，构造完成。 使用并查集维护联通块。 考虑最小生成树的构造过程，即选出 n−1n-1n−1 条边的顺序。 有一个贪心策略，按照边权升序排序，依次考虑是否选取。 如果两个端点 u,vu,vu,v 在一个联通块里，不选。否则选。 建立并查集。 按照边权排序，依次扫描每条边。 如果 u,vu,vu,v 属于同一连通块，则忽略，扫描下一条。否则选择这条边，合并两个并查集。 时间复杂度为 Θ(mlog⁡m)\\Theta(m \\log m)Θ(mlogm)。 例题：【模板】最小生成树 给出一个 nnn 个点，mmm 条边的无向图，判断其是否为联通图，并求出其最小生成树。 Dijkstra 算法 Dijkstra 算法是一种用于求解单源最短路问题的算法。 设 SSS 为起点，disxdis_xdisx​ 为 xxx 到 SSS 的最短距离。 流程如下： 初始化 disSdis_SdisS​ 为 000，disdisdis 的其他位置为 +∞+\\infty+∞。 在未被标记点中找到的 disxdis_xdisx​ 最小的 xxx，并标记结点 xxx。 扫描 xxx 的所有出边 (x,y,z)(x,y,z)(x,y,z) [1]^{[1]}[1]，如果 disy&gt;disx+zdis_y&gt;dis_x+zdisy​&gt;disx​+z，则更新 disydis_ydisy​。 重复步骤 2∼32 \\sim 32∼3，直至所有结点被标记。 Dijkstra 只能处理非负边权的图。 其思想基于贪心：当边长为非负数，全局最小值必然不可能再被更新。 即，每次在第二步中取出的 xxx，disxdis_xdisx​ 已经是起点到 xxx 的最短路径。 Dijkstra 的时间复杂度是 Θ(n2)\\Theta(n^2)Θ(n2)。 其时间复杂度瓶颈为寻找结点 xxx，这个过程可以用优先队列 priority_queue 优化。 优化后均摊时间复杂度为 Θ(nlog⁡n)\\Theta(n \\log n)Θ(nlogn)。 pair &lt;type,type&gt; 优先以第一关键字比大小，第一关键字相同按第二关键字比。 make_pair(a,b)，得到一个以 aaa 为第一关键字，bbb 为第二关键字的 pair。 例题：【模板】单源最短路径（标准版） 给出一个 nnn 个点 mmm 条边的有向图，求从 sss 出发到每个点的最短距离。 n≤105,m≤2×105,wi≤109,∑wi≤109n \\le 10^5,m \\le 2 \\times 10^5,w_i \\le 10^9,\\sum w_i \\le 10^9n≤105,m≤2×105,wi​≤109,∑wi​≤109 [1]^{[1]}[1] xxx 为该边起点，yyy 为该边终点，zzz 为该边长度。 Floyd 算法 Floyd 算法是用来求解全源最短路的算法，其基于动态规划思想。 使用邻接矩阵存储图。 设 Dk,i,jD_{k,i,j}Dk,i,j​ 为经过若干个编号不超过 kkk 的结点从 iii 到 jjj 的最短路长度。 有两种转移来源： 经过若干个编号不超过 k−1k-1k−1 的结点从 iii 到 jjj。 从 iii 到 kkk 再到 jjj。 即有 Dk,i,j=min⁡{Dk−1,i,j,Dk−1,i,k+Dk−1,k,j}D_{k,i,j}=\\min\\{D_{k-1,i,j},D_{k-1,i,k}+D_{k-1,k,j}\\}Dk,i,j​=min{Dk−1,i,j​,Dk−1,i,k​+Dk−1,k,j​}。 类似于背包问题，第一维 kkk 可以省略。 即有 Di,j=min⁡{Di,j,Di,k+Dk,j}D_{i,j}=\\min\\{D_{i,j},D_{i,k}+D_{k,j}\\}Di,j​=min{Di,j​,Di,k​+Dk,j​}。 由于动态规划的有序性，需要先枚举阶段转移点 kkk，再枚举 iii 和 jjj。 最终 Di,jD_{i,j}Di,j​ 即为 iii 到 jjj 的最短距离。 Floyd 算法的时间复杂度为 Θ(n3)\\Theta(n^3)Θ(n3)。 全源最短路问题也可以通过做 nnn 次 Dijkstra 在 Θ(n2log⁡n)\\Theta(n^2 \\log n)Θ(n2logn) 的时间复杂度内完成。 例题：【模板】Floyd 算法 给出一个 nnn 个点 mmm 条边的无向图，求任意两点间最短路径。 n≤100,m≤4500,wi≤1000n \\le 100,m \\le 4500,w_i \\le 1000n≤100,m≤4500,wi​≤1000 ","link":"https://Happy-Code-HC.github.io/post/yugu22nxj5/"},{"title":"XJ4 STL 的 set 与 priority_queue","content":"map map 是一种映射容器，其头文件是 map。 功能 说明 map&lt;x,y&gt; m 建立一个名字为 mmm 的映射，下标类型为 x，元素类型为 y。 m[x]=y 将 mxm_xmx​ 的值设为 yyy m.find(x)!=a.end() 判断 mxm_xmx​ 是否存在 m.erase(x) 将 mxm_xmx​ 删除 m.clear() 清空 mmm m.size() 返回 mmm 中的元素数量 遍历 map 可以使用迭代器。 map&lt;int,int&gt; m; for(map&lt;int,int&gt;::iterator i=m.begin();i!=m.end();i++){ int id=i-&gt;first; //id 为下标 int value=i-&gt;second;//value 为元素 } 其中 map&lt;int,int&gt;::iterator 在使用 C++11 以上时可替换为 auto，CSP-J/S 及 NOIP 等比赛可以使用。auto 为自动类型推断，请勿滥用 auto。 map 底层为二叉平衡树（红黑树），因此单次操作时间复杂度为 O(log⁡n)O(\\log n)O(logn)。 set set 是一个 不可重 集合，其头文件是 set。 功能 说明 set&lt;x&gt; s 建立一个名字为 sss 的集合，元素类型为 x。 s.insert(x) 将 xxx 插入集合 s.find(x)!=a.end() 判断 xxx 是否在集合中 s.erase(x) 将 xxx 从集合中删除删除 s.clear() 清空 sss s.size() 返回 sss 中的元素数量 遍历 set 可以使用迭代器。 set&lt;int&gt; s; for(set&lt;int&gt;::iterator i=s.begin();i!=s.end();i++){ int value=*i; } set 会自动将元素去重并进行升序排序。 map 底层为二叉平衡树，因此单次操作时间复杂度为 O(log⁡n)O(\\log n)O(logn)。 multiset multiset 与 set 类似，但是 multiset 是 可重的，其头文件是 set。 由于 multiset 是可重的，所以做删除操作有两种情况，分别是删除所有值为 x 的元素，和删除一个值为 x 的元素。 s.erase(x) //删除所有值为 x 的元素 if(s.find(x)!=s.end()){ s.erase(s.find(x)); //删除一个值为 x 的元素 } 可以通过 lower_bound() 函数与 upper_bound() 函数查询 mutiset 中 x 的前驱及后继。 set&lt;int&gt;::iterator it=s.lower_bound(x); it--; int pre=*it; //前驱 set&lt;int&gt;::iterator it=s.upper_bound(x); int nxt=*it; //后继 priority_queue priority_queue 是一个优先队列，在头文件 queue 中。 优先队列是一个弹出元素时弹出最大值的数据结构。 priority_queue 可在 O(log⁡n)O(\\log n)O(logn) 的时间复杂度插入元素，在 O(1)O(1)O(1) 的时间复杂度获取/弹出队首元素。 功能 说明 priority_queue&lt;x&gt; q 建立一个名字为 qqq 的优先队列，元素类型为 x，队首为最大值。 priority_queue&lt;x,vector&lt;x&gt;,greater&lt;x&gt; &gt; q 建立一个名字为 qqq 的优先队列，元素类型为 x，队首为最小值。 q.top() 获取队首元素 q.pop() 获取队首元素 q.size() 返回 qqq 中的元素数量 q.push(x) 将元素 xxx 插入到 qqq 中 例题：【模板】堆 给定一个数列，初始为空，请支持下面三种操作： 给定一个整数 xxx，请将 xxx 加入到数列中。 输出数列中最小的数。 删除数列中最小的数（如果有多个数最小，只删除 111 个）。 思路：使用 priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q 让最小值放在队首，按照题目说明及上方表格完成操作。 例题：合并果子 通过模拟合并的过程，我们会发现每次选择两个最小的元素合并成较大的元素是最优策略，可以由哈夫曼编码证明（具体请参考《深基》） 因而，每次从序列中找到最小值和次小值，将其相加再放入序列中即可。时间复杂度为 O(nlog⁡n)O(n \\log n)O(nlogn)。 ","link":"https://Happy-Code-HC.github.io/post/yugu22nxj4/"},{"title":"XJ7 第 2 周 授课","content":"一元二次方程求根 ax2+bx+c=0(a≠0)ax^2+bx+c=0 (a \\neq 0) ax2+bx+c=0(a​=0) x2+bax+ca=0x^2+\\frac{b}{a}x+\\frac{c}{a}=0 x2+ab​x+ac​=0 (x+b2a)2+ca−b24a2=0(x+\\frac{b}{2a})^2+\\frac{c}{a}-\\frac{b^2}{4a^2}=0 (x+2ab​)2+ac​−4a2b2​=0 (x+b2a)2=b2−4ac4a2(x+\\frac{b}{2a})^2=\\frac{b^2-4ac}{4a^2} (x+2ab​)2=4a2b2−4ac​ x+b2a=±b2−4ac2ax+\\frac{b}{2a}=\\frac{\\pm \\sqrt{b^2-4ac}}{2a} x+2ab​=2a±b2−4ac​​ x=−b±b2−4ac2ax=\\frac{-b \\pm \\sqrt{b^2-4ac}}{2a} x=2a−b±b2−4ac​​ 一元二次不等式 ax2+bx+c≤0(a&gt;0)ax^2+bx+c \\le 0 (a&gt;0) ax2+bx+c≤0(a&gt;0) −b−b2−4ac2a≤x≤−b+b2−4ac2a\\frac{-b-\\sqrt{b^2-4ac}}{2a} \\le x \\le \\frac{-b+\\sqrt{b^2-4ac}}{2a} 2a−b−b2−4ac​​≤x≤2a−b+b2−4ac​​ 令 Δ=b2−4ac\\Delta=b^2-4acΔ=b2−4ac，不等式有解条件为 Δ≥0\\Delta \\ge 0Δ≥0。 并查集 查找：如果当前节点的父亲是自身，则返回自身，否则查找其父亲。 路径压缩：查找时将该节点的祖先设为查找结果。 合并：将一个并查集的祖先设为另一个并查集的祖先的儿子。 启发式合并：小的并查集合并到大的并查集里面。不建议使用。 int find(int x){ if(f[x]==x){ return x; } return f[x]=find(f[x]); } void merge(int x,int y){ x=find(x); y=find(y); f[x]=y; } ","link":"https://Happy-Code-HC.github.io/post/yugu22nxj7/"},{"title":"XJ3 字符串问题","content":"字符串哈希 字符串哈希是一种将任意长度的字符串映射成一个非负整数的算法。 将字符串视为 PPP 进制数，对于字符集 [1]^{[1]}[1] 中的每一个字符，分配一个正整数。一般情况下，分配的数值都远小于 PPP，PPP 一般可以取 131131131 或 133311333113331。因为这个数可能很大，我们需要将这个数对 MMM 取模。在实践中，可以使用 unsigned long long 类型存储哈希值，在计算过程中不处理算数溢出问题。unsigned long long 在溢出时会自动对 2642^{64}264 取模。 可加性：记字符串 SSS 的哈希值为 H(S)\\text{H}(S)H(S)，在字符串 SSS 后增加一个字符 ccc，则 H(S+c)=(H(S)×P+V(c)) mod m\\text{H}(S+c)=(\\text{H}(S) \\times P+\\text{V}(c)) \\bmod mH(S+c)=(H(S)×P+V(c))modm，其中 V(c)\\text{V}(c)V(c) 代表给字符 ccc 赋予的值。 可减性：记字符串 S+TS+TS+T 的哈希值为 H(S+T)\\text{H}(S+T)H(S+T)，在字符串 SSS 后增加一个字符 ccc，则 H(T)=(H(S+T)−H(S)×P∣T∣) mod m\\text{H}(T)=(\\text{H}(S+T) - \\text{H}(S) \\times P^{|T|}) \\bmod mH(T)=(H(S+T)−H(S)×P∣T∣)modm，其中 ∣T∣|T|∣T∣ 代表给字符串 TTT 的长度。为保证时间复杂度，需要预处理 PPP 的若干次方。 因为字符串哈希具有可加性与可减性，因此可使用前缀和处理字符串哈希问题。以 O(∣S∣)O(|S|)O(∣S∣) 的时间复杂度处理字符串 SSS 的每个前缀的哈希值，用 O(1)O(1)O(1) 的时间复杂度查询字符串 SSS 的任意一个字串的哈希值。 例题：【模板】字符串哈希 给定 NNN 个字符串，第 iii 个字符串长度为 MiM_iMi​，字符串内包含数字、大小写字母，大小写敏感，请求出 NNN 个字符串中 共有多少个不同的字符串。 N≤10000N\\leq 10000N≤10000，Mi≈1000M_i \\approx 1000Mi​≈1000，max⁡M≤1500\\max M \\leq 1500maxM≤1500 样例输入： 5 abc aaaa abc abcc 12345 样例输出： 4 解法：读入所有字符串，计算并存储其哈希值，排序并使用 unique 函数去重。请注意 hash 这个名字在 string 头文件中已经被定义。 [1]^{[1]}[1] 字符集指可能出现在字符串中所有的字符组成的集合。 KMP KMP 算法是由三位 dalao 共同提出的一种可以在线性时间复杂度内解决模式串匹配问题的算法，用于解决 SSS 串在 TTT 串中出现的次数和位置。 暴力算法时间复杂度为 O(∣S∣∣T∣)O(|S||T|)O(∣S∣∣T∣)，显然不能通过大数据。 KMP 算法在程序上分为两步： 对字符串 SSS 进行自我匹配，即求出 nextnextnext 数组，nextinext_inexti​ 表示 SSS 中以 iii 为结尾的真子串，与 SSS 的前缀能够匹配的最大长度。 对字符串 SSS, TTT 进行匹配，求出 fff 数组，fif_ifi​ 表示 TTT 中以 iii 为结尾的子串，与 SSS 的前缀能够匹配的最大长度。 KMP 算法的核心是 nextnextnext 数组，nextinext_inexti​ 的本质为前 iii 个字母的最长公共前后缀。即有 nexti=max⁡{j}next_i = \\max\\{j\\}nexti​=max{j}，其中 j&lt;ij&lt;ij&lt;i 且有 Si−j+1∼i=S1∼iS_{i-j+1 \\sim i}=S_{1 \\sim i}Si−j+1∼i​=S1∼i​。 考虑 nextnextnext 数组的求法。 根据定义，有 next1=0next_1=0next1​=0。假设 next1∼i−1next_{1 \\sim i-1}next1∼i−1​ 已经计算完毕，当计算 nextinext_inexti​ 时，即需要找到满足下面条件的 jjj 的最大值。 j&lt;ij&lt;ij&lt;i Si−j+1∼i=S1∼jS_{i-j+1 \\sim i}=S_{1 \\sim j}Si−j+1∼i​=S1∼j​ 我们称满足上述条件的 jjj 为 nextinext_inexti​ 的候选项。 引理：若 j0j_0j0​ 是 nextinext_inexti​ 的一个候选项，则小于 j0j_0j0​ 的最大的 nextinext_inexti​ 的候选项是 nextj0next_{j_0}nextj0​​。 根据引理，当 nexti−1next_{i-1}nexti−1​ 计算完毕后，即可得知所有 nexti−1next_{i-1}nexti−1​ 的候选项，依次为 nexti−1next_{i-1}nexti−1​，nextnexti−1next_{next_{i-1}}nextnexti−1​​，……。如果一个整数 jjj 是 nextinext_inexti​ 的候选项，那么 j−1j-1j−1 一定是 nexti−1next_{i-1}nexti−1​ 的候选项。因此，计算 nextinext_inexti​ 的时候，只需把 nexti−1+1next_{i-1}+1nexti−1​+1，nextnexti−1+1next_{next_{i-1}}+1nextnexti−1​​+1，…… 作为候选项即可。 由于 fff 与 nextnextnext 定义相似，只需参考 nextnextnext 数组求出的方法即可求出 fff 数组。 例题：【模板】KMP字符串匹配 给出字符串 S,TS,TS,T，求 SSS 在 TTT 中出现的位置。最后一行输出 KMP 过程中求出的 nextnextnext 数组。 字符集为所有大写字母，且 1≤S,T≤1061 \\le S,T \\le 10^61≤S,T≤106。 样例输入： ABABABC ABA 样例输出： 1 3 0 0 1 解法：根据 KMP 算法求出 next,fnext,fnext,f 两个数组，如果 fi=∣S∣f_i=|S|fi​=∣S∣ 即为出现的终止位置。因为数组下标从 1 开始，所以字符串需使用 char 数组存储，输入时需从下标为 1 的地方开始输入。请注意 next 这个名字在 string 头文件中已经被定义。 字典树 字典树是一类 KKK 叉树，KKK 为字符集大小，用于字符串的快速检索。 每个节点都有 KKK 个字符指针，分别对应字符集中的每个字符。在插入或检索字符串的过程中，扫描到字符 ccc，就沿着对应的字符指针往下走即可。 一颗字典树在初始状态下只有一个空节点，其所有字符指针指向空。 插入：插入前取指针 PPP 指向字典树的根节点。如果 PPP 指向的节点对应 S1S_1S1​ 的指针为空，则新建节点。将指针 PPP 移动到该字符指针指向的节点。S2∼S∣S∣S_2 \\sim S_{|S|}S2​∼S∣S∣​ 同理。当字符串 SSS 插入完毕，在最后的节点上打上终止标记即可。 查找：依次扫描每个字符，如果对应的字符指针不存在，则字典树中没有这个字符串。如果当前节点有终止标记，则这个字符串曾经被插入到字典树中。 可以发现，关于字符串的数据都体现在边上，关于字符串终止与数目等附加信息的数据都体现在点上。 字典树的空间复杂度为 O(NC)O(NC)O(NC)，其中 NNN 代表结点个数，CCC 代表字符集大小。 字典树的应用十分广泛，主要集中于前缀相关，亦可用于字符串集的字典序排序。 例题：【模板】字典树 给出 NNN 个字符串，QQQ 组询问。 每组询问给出一个字符串 SSS，问 SSS 是给出的 NNN 个字符串中多少个字符串的前缀。 多测，TTT 组测试数据。 字符集为所有大写字母、小写字母和 0-9，且 T,N,Q≤105T,N,Q \\le 10^5T,N,Q≤105，字符串长度 ≤3×106\\le 3 \\times 10^6≤3×106。 样例输入： 1 3 3 fusufusu fusu anguei fusu anguei kkksc 样例输出： 2 1 0 解法：将所有字符串插入字典树，给每个经过的点打标记，查询记录最后走到的点，输出最后走到的点的标记数。多测需要使用循环清空数组。 0-1 Trie 是一种特殊的字典树。 将一个二进制数补齐前导 000，视作字符串插入正常的 Trie。 可以用于一些位运算相关的题目。 ","link":"https://Happy-Code-HC.github.io/post/yugu22nxj3/"},{"title":"P8219 题解","content":"思路 40 分 枚举 LLL 到 RRR 之间的每个 f(x)f(x)f(x) 的值，用“打擂台法”求出最大值。 注：“打擂台法”指如果当前值大于最大值，那么当前值就是最大值。详细解释请参考《深入浅出程序设计竞赛 - 基础篇》语言入门部分。 100 分 当 xxx 是偶数时， f(x)f(x)f(x) 为 x÷2x \\div 2x÷2。那 xxx 是奇数时呢？答案是：不管它！xxx 是奇数时，f(x)f(x)f(x) 至少为 x÷3x \\div 3x÷3，比 xxx 是偶数时大。因此答案是 ⌊x÷2⌋\\lfloor x \\div 2 \\rfloor⌊x÷2⌋，C++ 中整数除法有自动向下取整的功能，因此只需输出 R÷2R \\div 2R÷2 即可。 提醒 比赛时在做什么？有没有空？可以来 开 long long 吗？ 代码 #include&lt;iostream&gt; using namespace std; long long l,r; //开 long long int main(){ cin&gt;&gt;l&gt;&gt;r; cout&lt;&lt;r/2&lt;&lt;endl; return 0; } ","link":"https://Happy-Code-HC.github.io/post/solution-p8219/"},{"title":"P8152 题解","content":"思路 我们发现每次操作都会去除右下角的 111 个格子，并在右下角添加 n×nn \\times nn×n 个格子。 经过 kkk 次操作后，共减少了 kkk 个格子，增加了 n×n×kn \\times n \\times kn×n×k 个格子，所以最终格子的数量是 1−k+n×n×k1-k+n \\times n \\times k1−k+n×n×k。 提醒 一定要记得 mod 998244353\\bmod\\ 998244353mod 998244353。 还要开 __int128 或写高精度，因为答案可能会爆 unsigned long long。 代码 #include&lt;cstdio&gt; __int128 n,k,ans=1; inline __int128 read(){ __int128 s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch &gt; '9'){ if(ch == '-'){ w=-1; } ch=getchar(); } while(ch &gt;= '0' &amp;&amp; ch &lt;= '9'){ s=s*10+ch-'0'; ch=getchar(); } return s*w; } inline void write(__int128 x){ if(x&lt;0){ putchar('-'); x=-x; } if(x&gt;9){ write(x/10); } putchar(x%10+'0'); } int main(){ n=read(); k=read(); ans=ans-k+n*n*k; write(ans%998244353); return 0; } 更新日志 upd 2022.2.18：快写竟然写错了，改了一下。 ","link":"https://Happy-Code-HC.github.io/post/solution-p8152/"},{"title":"P8318 题解","content":"思路 很明显我们恢复序列时要把加法变成减法，把乘法变成除法，但因为猴子是从前往后操作的，所以我们要从后往前恢复。 特别且显然地，当 x=yx=yx=y，新的 xxx 就等于原来的 xxx 两倍或平方。 如果 x=yx=yx=y，且操作为 111 号操作，我们就需要把 bxb_xbx​ 的值除以 222，若为 222 号操作，我们就需要把 bxb_xbx​ 变为 bx\\sqrt{b_x}bx​​。 提醒 恢复序列时要从最后一个操作开始恢复！ 代码 #include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; int n,m,k[205],x[205],y[205]; long long b[1005]; int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;b[i]; } for(int i=1;i&lt;=m;i++){ cin&gt;&gt;k[i]&gt;&gt;x[i]&gt;&gt;y[i]; } for(int i=m;i&gt;=1;i--){ if(k[i]==1){ if(x[i]==y[i]){ b[x[i]]/=2; }else{ b[x[i]]-=b[y[i]]; } } if(k[i]==2){ if(x[i]==y[i]){ b[x[i]]=sqrt(b[x[i]]); }else{ b[x[i]]/=b[y[i]]; } } } for(int i=1;i&lt;=n;i++){ cout&lt;&lt;b[i]&lt;&lt;' '; } return 0; } ","link":"https://Happy-Code-HC.github.io/post/solution-p8318/"},{"title":"P8071 题解","content":"思路 我们想要知道比 H:MH:MH:M 早 454545 分钟的时间就要把 MMM 减少 454545。 但是这题就这么简单吗？不是的，有可能提前 454545 分钟就到了上一个小时，如果 M&lt;0M&lt;0M&lt;0 就到了上一个小时。 这时，我们需要将小时 HHH 减 111，分钟 MMM 加 606060。 还有可能提前 454545 分钟就到了上一天，如果 H&lt;0H&lt;0H&lt;0 就到了上一天。 这时，我们需要将小时 HHH 加 242424，因为跨天就一定垮了小时，所以不用考虑分钟的问题。 提醒 要特判跨小时和跨天的情况！ 代码 #include&lt;iostream&gt; using namespace std; int h,m; int main(){ cin&gt;&gt;h&gt;&gt;m; m-=45; if(m&lt;0){ //要特判跨小时的情况 h-=1; m+=60; } if(h&lt;0){ //要特判跨天的情况 h+=24; } cout&lt;&lt;h&lt;&lt;' '&lt;&lt;m&lt;&lt;endl; return 0; } data=input().split() data[0]=int(data[0]) data[1]=int(data[1]) data[1]-=45 if(data[1]&lt;0): #要特判跨小时的情况 data[0]-=1 data[1]+=60 if(data[0]&lt;0): #要特判跨天的情况 data[0]+=24 print(data[0],data[1]) 更新日志 upd 2022.2.15：改正了 不用跨天 这一错误，并加入了 Python 代码。虽然数据没有，但是题面说明中有 H=0H=0H=0 的情况。 ","link":"https://Happy-Code-HC.github.io/post/solution-p8071/"},{"title":"P8032 题解","content":"思路 我们枚举输入的数组的每个值。 如果该值为 {，除第一行以外换一行，然后输出缩进，然后加 222 个空格的缩进。 如果该值为 }，减掉 222 个空格的缩进，然后换一行输出缩进和 }。 如果该值为 ,，直接输出。 如果该值为数组元素且上一个时 { 或 ,，换一行输出缩进和元素。 提醒 这题有 SPJ，第一行不能有换行！ 代码 #include&lt;iostream&gt; using namespace std; string s; int tab; char last='\\0'; int main(){ cin&gt;&gt;s; for(int i=0;i&lt;s.length();i++){ if(s[i]=='{'){ if(last!='\\0'){ //第一行不能有换行 cout&lt;&lt;endl; } for(int i=1;i&lt;=tab;i++){ cout&lt;&lt;' '; } cout&lt;&lt;'{'; tab+=2; last='{'; }else if(s[i]=='}'){ tab-=2; cout&lt;&lt;endl; for(int i=1;i&lt;=tab;i++){ cout&lt;&lt;' '; } cout&lt;&lt;'}'; last='}'; }else if(s[i]==','){ cout&lt;&lt;','; last=','; }else{ if(last=='{' or last==','){ cout&lt;&lt;endl; for(int i=1;i&lt;=tab;i++){ cout&lt;&lt;' '; } } cout&lt;&lt;s[i]; last=s[i]; } } return 0; } ","link":"https://Happy-Code-HC.github.io/post/solution-p8032/"},{"title":"P7917 题解","content":"思路 这题需要将 nnn 个整数相邻两个进行加减运算，问最大是多少。但实际上就是在 nnn 个数字间填上加减号，求最大值。 加一个整数原数变大，减一个负数原数变小。 但算式开头默认有个加号，所以第一个数必须要加上，不管它是否是负数。 我们定义一个 sss，存储 aaa 数组中最大的和，然后去遍历 aaa 数组。 如果 ai≥0a_i \\ge 0ai​≥0，那么就将 sss 增加 aia_iai​。 如果 ai≤0a_i \\le 0ai​≤0，那么就将 sss 减少 aia_iai​。 但要注意，当 i=1i=1i=1 时，必须将 sss 增加 aia_iai​ 提醒 还是那句话：十年 OI 一场空，不开 long long 见祖宗。 再提醒一句：第一个数只能加上！我在月赛过程中就因为这个 Boom 0 了无数次！ 代码 #include&lt;iostream&gt; using namespace std; long long n,a[100005],s; int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i]; } for(int i=1;i&lt;=n;i++){ if(a[i]&gt;=0){ s+=a[i]; //正数就加 }else if(i!=1){ s-=a[i]; //负数就减 }else{ s+=a[i]; //第一个只能加上！ } } cout&lt;&lt;s&lt;&lt;endl; return 0; } ","link":"https://Happy-Code-HC.github.io/post/solution-p7917/"},{"title":"P7901 题解","content":"思路 这题是道数学题。 每经过一次琢喵就会经过坐标为 (x,y)(x,y)(x,y) 的点，但是起点可以是的任意点，那么琢喵在哪里就对答案没有影响。 所以我们找矩形的点数 nnn 和步数 kkk 的关系,也就是找 2n×2n2n \\times 2n2n×2n 和 kkk 的关系。每走一轮就会经过琢喵一遍，经过的次数是 k÷(2n×2n)k\\div(2n \\times 2n)k÷(2n×2n)。 提醒 xxx 和 yyy 在洛谷可以不读入，但在某些 OJ 就必须读入，否则会离奇报错，所以建议读入所有变量。 Python 做完除法要输出整数必须强制转换成 int 类型。 最后提醒一句：十年 OI 一场空，不开 long long 见祖宗。 代码 结论题，不给注释 #include&lt;iostream&gt; using namespace std; long long n,k,x,y; int main(){ cin&gt;&gt;n&gt;&gt;k&gt;&gt;x&gt;&gt;y; cout&lt;&lt;k/(n*2*n*2)&lt;&lt;endl; return 0; } a=input().split() a[0]=int(a[0]) a[1]=int(a[1]) print(int(a[1]/(a[0]*2*a[0]*2))) 更新日志 upd 2021.10.25：补充了 Python 代码 upd 2022.4.12： 更改了 Python 代码中的错误，并将该错误加入提醒中。 将 结论题 修改为 数学题。 将没添加/英文的句号全部添加/修改。 ","link":"https://Happy-Code-HC.github.io/post/solution-p7901/"}]}